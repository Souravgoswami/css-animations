#!/usr/bin/ruby -w
# Frozen_String_Literal: true
%w(erb io/console webrick).each(&method(:require))
OUTPUT_FILE = File.join(__dir__, 'index.html')

COLOUR_SUCCESS = "\e[1;38;2;0;165;45m"
COLOUR_INFO = "\e[1;38;2;255;255;0m"
COLOUR_ERROR = "\e[1;38;2;215;80;90m"
COLOUR_WARNING = "\e[1;38;2;255;180;0m"
COLOUR_PRIMARY = "\e[1;38;2;0;125;255m"

def init
	unless File.exist?(OUTPUT_FILE)
		f = File.basename(Process.argv0)
		emojis = %W(
			\xF0\x9F\x90\xB9 \xF0\x9F\x90\xAD \xF0\x9F\x90\xB1
			\xF0\x9F\x90\xA3 \xF0\x9F\x90\xB5 \xF0\x9F\x90\xBC
		)

		IO.write(
			OUTPUT_FILE,
			<<~EOF
				<!Doctype HTML><html><head><meta charset="utf-8"><title>Welcome to #{f}</title><style>
				body { height: 100vh ; display: flex ; justify-content: center ; align-items: center ;
				flex-direction: column }h2 { color: ##{6.times.map { [(?a..?f).to_a.sample, rand(0..9)].sample }.join} }
				.btn { position: relative ; text-decoration: none ; font-size: 20px ; color: #fa0 ;
				padding: 10px 20px ;border: 3px solid #fa0 ; border-radius: 4px ;
				overflow: hidden ; background-color: transparent } .btn::after { content: attr(data-content) }
				.btn::before { content: attr(data-content) ; color: #fff ; display: flex ;
				align-items: center ; justify-content: center ;position: absolute ; top: 0 ;
				left: 0 ; width: 100% ; height: 100% ; background-color: #fa0 ; filter: blur(6px) ;
				transition: all 0.5s ease ; transform: scale(5) ; opacity: 0 }
				.btn:hover::before { transform: scale(1.2) ; opacity: 1 ; filter: blur(0px) }
				#x { background-color: #fff ; border-radius: 4px ; filter: drop-shadow(4px 4px 4px #222222aa) ;
				margin-bottom: 20px } #w { margin: 20px ; max-width: 75vw } .btn:active::before,
				.btn:focus::before { background-color: #00A32C } .btn:active, .btn:focus { border-color: #00A32C ; color: #f55 }
				</style></head><body><div id="x"><div id="w"><h2>This dummy file is generated by #{f}</h2>
				<p>#{emojis.sample} Please create a file with .html.erb extension to reload it on the browser.</p>
				<p>#{emojis.sample} You can create others file, and this view will get updated!</p>
				<p>#{emojis.sample} This is handy when you are creating lots of html files and want to test them out.</p>
				<p>#{emojis.sample} Just remember to place your stylesheets, js files, assets, and other stuff in the #{__dir__}/</p>
				<p>#{emojis.sample} I am watching for files! Please reload the page once you are done!</p>
				<center><button class="btn" href="#" data-content="Reload" onclick="window.location.reload()"></button></center>
				</div></div></body></html>
			EOF
		)
	end

	puts "#{COLOUR_PRIMARY}:: Watching for modified or new .html.erb files in #{__dir__}\e[0m"
	puts "#{COLOUR_SUCCESS}:: Found #{Dir["#{__dir__}/**/*.html.erb".freeze].count} html.erb files so far...\e[0m\n\n"
end

def start_server
	port = 8080

	begin
		WEBrick::HTTPServer.new(
			Port: port, DocumentRoot: __dir__,
			BindAddress: '0.0.0.0',
			Logger: WEBrick::Log.new(File::NULL)
		).start
	rescue Errno::EADDRINUSE
		puts "#{COLOUR_INFO}:: Error: Port #{port} is unavailable! Retrying to http://0.0.0.0:#{port += 1}\e[0m"
		sleep 0.05
		retry
	end
end

def main
	updated_at = Time.now.to_i
	output_file = OUTPUT_FILE
	anim = %W(\xE2\xA0\x82 \xE2\xA0\x90 \xE2\xA0\xA0 \xE2\xA0\xA4 \xE2\xA0\x86)
	ellipses = %w(. .. ...)

	while files = Dir["#{__dir__}/**/*.html.erb".freeze].tap(&:sort!)
		files.each do |file|
			mtime, w = File.mtime(file), STDOUT.winsize[1]

			if (mtime_i = mtime.to_i) > updated_at
				sleep 0.125
				updated_at = mtime_i
				contents = IO.read(output_file) if File.readable?(output_file)
				puts "\n\e[1;38;2;0;180;0m:: Compiling a newly modified file #{file}...\e[0m"

				begin
					compiled_html = <<~EOF
						<!Doctype HTML>
						<html>
						<!-- This file is generated by #{File.basename(Process.argv0)} -->
						<!-- Read #{file} for source code. -->
						#{ERB.new(IO.readlines(file).each(&:strip!).join(?\n)).result.split(?\n).tap { |x| x.reject!(&:empty?) }.join(?\n)}
						</html>
					EOF

					if contents != compiled_html
						IO.write(output_file.tap { |f| puts "\n#{?\s.*((w / 2 - f.length / 2 - 4).clamp(0, Float::INFINITY))}#{COLOUR_PRIMARY}\e[4mUpdating #{f}\e[0m\n" + "\e[0m" }, compiled_html)
						puts "\e[38;2;255;170;40m#{compiled_html}\e[0m"
						puts "#{COLOUR_SUCCESS}:: Successfully updated #{file} at #{mtime}".center(w) + "\e[0m"
					else
						puts "\n#{COLOUR_WARNING}:: Skipped, File has same content...\e[0m"
					end
				rescue Exception
					puts "#{COLOUR_ERROR}#{' :: Error '.center(w, ?-)}\e[0m"
					puts "#{$!.to_s.each_line.map { |el| el.prepend('| ').concat(' |'.rjust(w - el.length)) }.join}"
					puts "\e[1;38;2;255;80;80m#{?- * w}\e[0m"
				ensure
					puts "\e[1m#{?-.*(3).center(w)}\e[0m"
				end
			end
		end

		print " \e[2K#{COLOUR_PRIMARY}#{anim.rotate![0]} Watching for file changes#{ellipses.rotate![0]}\e[0m\r"
		sleep(0.25)
	end

end

begin
	init
	Thread.new { start_server }
	main
rescue Interrupt, SystemExit, SignalException
	puts "\n:: Good Bye!"
rescue Exception
	abort $!.full_message
end
